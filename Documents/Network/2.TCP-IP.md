# 0.序

TCP/IP 协议过去是一个，后来拆分为两个。  
应用程序使用 Socket 库和解析器 =>  
操作系统协议栈，包括 TCP(transmission control protocol)/UDP(user datagram protocol) 连接，以及下层的 IP(internet protocol)/ICMP(internet control message protocol)/ARP(address resolution protocol) 网络传输 =>  
驱动程序，主要是控制网卡的驱动程序 =>  
硬件，网卡

> TCP/UDP 协议用来接受应用程序的委托收发数据；  
> IP 协议用来控制网络包收发操作；  
> ICMP 协议用于告知网络包传送过程中的错误以及各种控制消息；  
> ARP 协议用于根据 IP 地址查询响应的以太网 MAC 地址；  
> 协议栈内部有一块用于存放控制信息的内存空间，记录了用于控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的进行状态。

# 1. socket 套接字

## 1.1 查看套接字

`netstat` 用来查看，展示信息包括协议类型（TCP/UDP）、本地 IP 地址和端口号、通信对象 IP 地址和端口号、通信状态（LISTENING/ESTABLISHED...）、进程标识符。

## 1.2 调用 socket

### 1.2.1

应用程序（浏览器）调用 gethostbyname(...)，通过 UDP 和 IP 模块查询 DNS 服务器。

### 1.2.2

应用程序调用 socket(...) 创建套接字，分配一块内存空间，存储协议栈返回的描述符和其他对象同步信息，`控制信息`的一部分存储在这。

### 1.2.3

应用程序调用 connect(...) 与服务器进行连接，获取服务器的 IP 地址和端口号等信息。客户端与服务器相互联络时交互`控制信息`，定义在 TCP 协议的头部中。

> 发送方端口号：16 bit，代表发送网络包的程序的端口号；  
> 接收方端口号：16 bit，代表网络包的接收方程序的端口号；  
> 序号：32 bit，发送方告知接收方该网络包发送的数据相当于所有发送数据的第几个字节；  
> ACK 号：32 bit，接收方告知发送方已经收到了所有数据的第几个字节；  
> 数据偏移量：4 bit，数据部分起始位置，即头部的长度；  
> 保留：6 bit，未使用，保留字段；  
> 控制位：6 bit，表示通信的控制含义，6 位分别代表 URG（紧急指针字段有效），ACK（接收数据需要字段有效，一般表示数据已被接收方收到），PSH（通过 flush 操作发送的数据），RST（强制断开连接，用于异常中断的情况），SYN（发送方和接收方确认序号，表示连接操作），FIN（表示断开连接）；  
> 窗口：16 bit，接收方告知发送方窗口大小；  
> 校验和：16 bit，用来检查是否出现错误；  
> 紧急指针：16 bit，表示应紧急处理的数据位置；
> 可选字段：可变长度，可添加可选字段，除了连接操作很少使用。

应用程序发出 `connect(<描述符>,<服务器 IP 地址和端口号>,...)`，在 TCP 模块创建表示上述连接控制信息的头部，TCP 模块将信息传递给 IP 模块并委托进行发送，网络包通过网络到达服务器，服务器 IP 模块将接受到的数据传递给 TCP 模块，服务器的 TCP 模块根据头部信息找到端口号对应的套接字，根据套接字写入响应信息，将状态修改为正在连接返回响应，网络包到达客户端，通过 IP 模块到达 TCP 模块，通过头部信息确认服务器连接操作是否成功，成功则将状态修改为连接完毕，ACK 信号位设置为 1 返回服务器。

### 1.2.4

协议栈收到应用程序调用 write 发送的数据后执行发送操作，协议栈不关心数据内容，只是发送一定长度的二进制文件。  
发送时机有两个控制因素：时间和数据大小。协议栈建立了缓冲区，如果数据过小，达到一定数据大小后才会发送，这样避免了一系列的小包的发送，如果数据过大，协议栈会对其进行拆分，MTU Maximum Transition Unit 设置了网络包的最大长度，减去头部的长度才是数据的长度 MSS Maximum Segment Size；另一个是时间，避免延时过大传输数据。同时协议栈也给应用保留了控制发送时机的余地，比如指定不等待填满缓冲区直接发送的选项。  
双方通信通过 ACK 号确认网络包已收到，TCP 模块在拆分数据时算好每块数据的开始字节，写在 TCP 头部的“序号”字段，发送数据的长度通过网络包长度减去头部长度由接收方自行计算，即发送方给出两个信息：（1）从第几个字节开始传输（2）共传输多少字节。接收方确认后回复到 XX 字节前数据已经接收。实际传输序号不是从 1 开始，会由发出方生成一个随机数设置初始值，以免通信被预测而受到攻击，初始值是在 SYN 设置为 1 的同时设置的。没有得到 ACK 返回的数据都在缓冲区中，必要时重发，因为这样的可靠性保障，网卡、集线器、路由器都可以在检测到错误后丢弃相应的包。  
网络耗时是波动的，所以会定义超时时间，即返回 ACK 号的等待时间，TCP 采取了动态调整等待时间的方法。在数据发送时，接收方首先告知发送方自己能最多接收多少数据，发送方会根据这个值操作，使用滑动窗口的方式并行的发送数据，但不会超过接送方的接收上限。ACK 和窗口更新大小是双方收发数据频繁要更新的部分，有两个主要优化，一个是需要发送多个 ACK 时，只发送最后一个省略中间的，另一个是只在接收方从缓冲区处理数据后更新窗口大小，二者的信息传递也可以合并在一个网络包里。  
当数据发送后，浏览器会调用 read 程序来获取响应信息，协议栈尝试从缓冲区取出数据传递给应用程序，没有获得响应时挂起，响应后协议栈根据 TCP 头部内容判断数据完整性，没有问题会返回 ACK 号，接着将数据块暂存到接收缓冲区中，按顺序拼接还原数据后交给应用程序，即将接受到的数据写入应用程序指定的内存地址中，再将控制流程交还给应用程序。最后协议栈还需要找到合适时机向发送方发送窗口更新。

### 1.2.5

完成数据发送的一方会发起断开过程，例如服务端断开：

- 服务端首先调用 Socket 库的 close 程序
- 服务端协议栈生成断开信息的 TCP 头部，控制位的 FIN 设置为 1
- 服务端协议栈委托 IP 模块发送数据
- 服务端套接字记录断开操作的信息
- 客户端收到 TCP 头部 FIN 为 1
- 客户端协议栈将自己的套接字标记为进入断开操作状态
- 客户端返回 ACK 号
- 客户端应用程序 read 读取数据时，协议栈不再传递数据，而是告知发送完毕
- 客户端应用程序调用 close 结束数据收发操作
- 客户端生成断开信息的 TCP 头部，控制位的 FIN 设置为 1
- 客户端协议栈委托 IP 模块发送数据
- 服务器收到后返回 ACK 号  
  套接字不会立即删除，因为要防止误操作。例如，最后返回 FIN 的 ACK 丢失了，这时会重发，如果套接字删除了则对应的控制信息也就删除了，端口被释放，如果恰巧其他套接字用了这个端口，新套接字就被删除了。协议中对于这个等待时间没有明确的规定，一般来说会等待几分钟之后再删除套接字。

# 2.IP 与以太网包收发

## 2.1 网络包

- 组成  
  头部：包含目的地等控制信息；MAC 头部（用于以太网协议）；IP 头部（用于 IP 协议)  
  数据
- 结构  
  发送方  
  转发设备：根据头部信息查表，判断包的发送方向；路由器，根据目标地址判断下一个路由器位置，按照 IP 规则传输包的设置  
  集线器：在子网中将网络包传输到下一个路由，按照以太网规则传输包的设备  
  接收方
- 传输方式  
  发送方将包的目的地 IP 地址写入 IP 头部；  
  IP 协议委托以太网协议将包传输过去，IP 找到下一个路由器的 MAC 地址，写入 MAC 头部；  
  网络包经过集线器传输，通过集线器找到下一个路由器；  
  路由器根据 IP 头部信息在 IP 协议表查出下一个路由器 MAC 地址，记录到 MAC 头部，发往下一个节点；  
  不断重复直到到达。

## 2.2 包收发操作

- 操作起点是 TCP 模块委托 IP 模块发送包
- IP 模块将包的内容当做一整块数据，在前面加上控制信息：IP 头部和 MAC 头部
- 封装好的包被交给网络硬件，传递给网卡的包是一串 0 和 1 的数字信息，网卡将数字信息转换为电信号或光信号，通过网线/光纤传输出去，到达集线器、路由器等转发设备，直到接收方

## 2.3 IP 地址

IP 地址不是分配给计算机的，而是分配给网卡的。如果计算机上有多个网卡，每块网卡都有自己的 IP 地址。  
通过路由表匹配目标 IP 地址：

- 将套接字中的目的地 IP 地址与路由表第一列 Network Destination 比较，找到对应行
- 第二列是 Interface 表示网卡等网络接口
- 第三列是 Gateway 表示下一个路由器的 IP 地址
- 如果无法匹配，会自动匹配第一行，目标地址和子网掩码都是 0.0.0.0，代表默认网关

## 2.4 MAC 头部

包含接收方 MAC 地址、发送方 MAC 地址和以太类型（0800 表示 IP 协议，0806 表示 ARP 协议，86DD 表示 IPv6 协议）。  
发送方的 MAC 地址在网卡生产时就写入到 ROM 中，直接获取填入即可。  
接收方的 MAC 地址使用路由表中匹配条目 Gateway 的 IP 地址对应设备的 MAC 地址，通过 ARP 查询目标路由器 MAC 地址后填入。

## 2.5 网卡

网卡驱动从 IP 模块获取包之后，会将其复制到网卡的缓冲区，然后向 MAC 模块发送发送包的指令。  
MAC 模块将包从缓冲区取出，在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列后发出。

> MAC 头部很容易误解为由网卡处理的，实际是由 TCP/IP 软件部分负责的
